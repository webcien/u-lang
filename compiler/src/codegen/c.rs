// c.rs — U v0.7 C Code Generator
// MIT License — Copyright (c) 2025 Webcien and U contributors

use crate::parser::{BinaryOp, Declaration, Expression, Function, Literal, Statement, Type, UnaryOp, Actor, Trait, TypeDef, TraitImpl};
use std::collections::HashSet;
use std::fmt::Write;

pub struct CGenerator {
    output: String,
    indent_level: usize,
    current_params: HashSet<String>,
}

impl CGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
            current_params: HashSet::new(),
        }
    }

    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }

    fn emit(&mut self, line: &str) {
        let indent_str = self.indent();
        writeln!(&mut self.output, "{}{}", indent_str, line).unwrap();
    }

    fn emitln(&mut self) {
        self.output.push('\n');
    }

    pub fn generate_program(&mut self, declarations: Vec<Declaration>) -> String {
        // Minimal header
        self.emit("// Generated by U v0.7 — DO NOT EDIT");
        self.emit("#include <stdio.h>");
        self.emit("#include <stdlib.h>");
        self.emit("#include <string.h>");
        self.emitln();

        // Forward declarations
        for decl in &declarations {
            if let Declaration::Function(f) = decl {
                self.generate_function_prototype(f);
            }
        }
        self.emitln();

        // Declarations
        for decl in declarations {
            self.generate_declaration(decl);
        }

        self.output.clone()
    }

    fn generate_function_prototype(&mut self, f: &Function) {
        let return_type = if f.name == "main" {
            "int"
        } else if f.return_type.is_some() {
            "int"
        } else {
            "void"
        };

        let params = if f.params.is_empty() {
            "void".to_string()
        } else {
            f.params
                .iter()
                .map(|(name, ty)| format!("{} {}", self.type_to_c(ty), name))
                .collect::<Vec<_>>()
                .join(", ")
        };

        self.emit(&format!("{} {}({});", return_type, f.name, params));
    }

    fn generate_declaration(&mut self, decl: Declaration) {
        match decl {
            Declaration::Function(f) => self.generate_function(f),
            Declaration::Actor(_) => {
                // Actors: struct generation deferred to v0.9
            }
            Declaration::Trait(_) => {
                // Traits: vtable generation deferred to v0.9
            }
            Declaration::TypeDef(_) => {
                // Type definitions: struct generation deferred to v0.9
            }
            Declaration::TraitImpl(_) => {
                // Trait implementations: method generation deferred to v0.9
            }
            Declaration::ExternBlock(block) => {
                self.generate_extern_block(block);
            }
        }
    }

    fn generate_function(&mut self, f: Function) {
        // Clear previous parameters
        self.current_params.clear();
        for (name, _) in &f.params {
            self.current_params.insert(name.clone());
        }

        // Return type (main always returns int, others based on signature)
        let return_type = if f.name == "main" {
            "int"
        } else if f.return_type.is_some() {
            "int"
        } else {
            "void"
        };

        let params = if f.params.is_empty() {
            "void".to_string()
        } else {
            f.params
                .iter()
                .map(|(name, ty)| format!("{} {}", self.type_to_c(ty), name))
                .collect::<Vec<_>>()
                .join(", ")
        };

        // Signature
        self.emit(&format!("{} {}({}) {{", return_type, f.name, params));
        self.indent_level += 1;

        // Body
        for stmt in f.body {
            self.generate_statement(stmt);
        }

        self.indent_level -= 1;
        self.emit("}");
        self.emitln();
    }

    fn type_to_c(&self, ty: &Type) -> String {
        match ty {
            Type::I32 => "int".to_string(),
            Type::Bool => "int".to_string(),
            Type::Str => "const char*".to_string(),
            Type::Ptr => "void*".to_string(),
            Type::Option(inner) => {
                format!("struct {{ {} value; int is_some; }}", self.type_to_c(inner))
            }
            Type::Result(ok, _) => {
                format!("struct {{ {} value; int is_ok; }}", self.type_to_c(ok))
            }
            Type::Custom(name) => format!("struct {}", name),
            Type::Generic { name, type_args: _ } => format!("struct {}", name),
            Type::FunctionPointer { params, return_type } => {
                let ret = if let Some(r) = return_type {
                    self.type_to_c(r)
                } else {
                    "void".to_string()
                };
                let param_str = params.iter()
                    .map(|t| self.type_to_c(t))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{}(*)({})", ret, param_str)
            }
        }
    }

    fn generate_statement(&mut self, stmt: Statement) {
        match stmt {
            Statement::Let { name, mutable: _, value } => {
                let c_type = self.expr_type_to_c(&value);
                let c_value = self.expr_to_c(value);
                self.emit(&format!("{} {} = {};", c_type, name, c_value));
            }
            Statement::Expr(expr) => {
                let c_expr = self.expr_to_c(expr);
                self.emit(&format!("{};", c_expr));
            }
            Statement::Return(expr) => {
                let c_expr = self.expr_to_c(expr);
                self.emit(&format!("return {};", c_expr));
            }
            Statement::If { condition, then_branch, else_branch } => {
                let cond = self.expr_to_c(condition);
                self.emit(&format!("if ({}) {{", cond));
                self.indent_level += 1;
                for stmt in then_branch {
                    self.generate_statement(stmt);
                }
                self.indent_level -= 1;
                if let Some(else_stmts) = else_branch {
                    self.emit("} else {");
                    self.indent_level += 1;
                    for stmt in else_stmts {
                        self.generate_statement(stmt);
                    }
                    self.indent_level -= 1;
                    self.emit("}");
                } else {
                    self.emit("}");
                }
            }
            Statement::While { condition, body } => {
                let cond = self.expr_to_c(condition);
                self.emit(&format!("while ({}) {{", cond));
                self.indent_level += 1;
                for stmt in body {
                    self.generate_statement(stmt);
                }
                self.indent_level -= 1;
                self.emit("}");
            }
            Statement::For { variable, iterable, body } => {
                let iter = self.expr_to_c(iterable);
                self.emit(&format!("for (int {} = 0; {} < {}; {}++) {{", variable, variable, iter, variable));
                self.indent_level += 1;
                for stmt in body {
                    self.generate_statement(stmt);
                }
                self.indent_level -= 1;
                self.emit("}");
            }
            Statement::Break => {
                self.emit("break;");
            }
            Statement::Continue => {
                self.emit("continue;");
            }
            Statement::Unsafe { body } => {
                // Unsafe blocks: generate C code directly without additional wrapping
                for stmt in body {
                    self.generate_statement(stmt);
                }
            }
        }
    }

    fn expr_type_to_c(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(Literal::Integer(_)) => "int".to_string(),
            Expression::Literal(Literal::String(_)) => "const char*".to_string(),
            Expression::Literal(Literal::Boolean(_)) => "int".to_string(),
            Expression::FunctionCall { name, .. } => {
                // For function calls, try to infer based on known patterns
                // Memory allocation functions
                if name == "malloc" || name == "calloc" || name == "realloc" {
                    return "void*".to_string();
                }
                
                // Skia functions that return pointers
                if name.starts_with("u_skia_") {
                    if name.contains("create") || name.contains("get_") || name.contains("version") {
                        return "void*".to_string();
                    }
                }
                
                // Default to int
                "int".to_string()
            }
            _ => "int".to_string(),
        }
    }

    fn expr_to_c(&self, expr: Expression) -> String {
        match expr {
            Expression::Literal(lit) => match lit {
                Literal::Integer(n) => n.to_string(),
                Literal::String(s) => format!("\"{}\"", s.escape_default()),
                Literal::Boolean(b) => if b { "1" } else { "0" }.to_string(),
            },
            Expression::Identifier(name) => name,
            Expression::FunctionCall { name, arguments } => {
                let args = arguments
                    .into_iter()
                    .map(|arg| self.expr_to_c(arg))
                    .collect::<Vec<_>>()
                    .join(", ");
                if name == "print" {
                    format!("printf(\"%d\\n\", {})", args)
                } else {
                    format!("{}({})", name, args)
                }
            }
            Expression::MethodCall {
                receiver: _,
                method: _,
                arguments: _,
            } => {
                "0 /* method call stub */".to_string()
            }
            Expression::Binary { left, operator, right } => {
                let left_c = self.expr_to_c(*left);
                let right_c = self.expr_to_c(*right);
                let op_str = match operator {
                    BinaryOp::Add => "+",
                    BinaryOp::Subtract => "-",
                    BinaryOp::Multiply => "*",
                    BinaryOp::Divide => "/",
                    BinaryOp::Modulo => "%",
                    BinaryOp::Equal => "==",
                    BinaryOp::NotEqual => "!=",
                    BinaryOp::Less => "<",
                    BinaryOp::LessEqual => "<=",
                    BinaryOp::Greater => ">",
                    BinaryOp::GreaterEqual => ">=",
                    BinaryOp::And => "&&",
                    BinaryOp::Or => "||",
                };
                format!("({} {} {})", left_c, op_str, right_c)
            }
            Expression::Unary { operator, operand } => {
                let op_c = self.expr_to_c(*operand);
                match operator {
                    UnaryOp::Not => format!("(!{})", op_c),
                    UnaryOp::Negate => format!("(-{})", op_c),
                }
            }
            Expression::Assignment { target, value } => {
                let val_c = self.expr_to_c(*value);
                format!("({} = {})", target, val_c)
            }
        }
    }

    fn generate_extern_block(&mut self, block: crate::parser::ExternBlock) {
        self.emit(&format!("// extern \"{}\" block", block.abi));
        for func in block.functions {
            self.generate_extern_function(&func);
        }
        self.emitln();
    }
    
    fn generate_extern_function(&mut self, func: &crate::parser::ExternFunction) {
        // Skip standard C library functions that are already declared in headers
        let stdlib_functions = [
            "printf", "scanf", "fprintf", "sprintf", "snprintf",
            "malloc", "free", "calloc", "realloc",
            "strlen", "strcpy", "strcmp", "strcat",
            "memcpy", "memset", "memmove",
            "fopen", "fclose", "fread", "fwrite",
            "exit", "abort", "atexit"
        ];
        
        if stdlib_functions.contains(&func.name.as_str()) {
            // Skip - already declared in standard headers
            return;
        }
        
        // Generate C function declaration
        let return_type = if let Some(ref ty) = func.return_type {
            self.type_to_c(ty)
        } else {
            "void".to_string()
        };
        
        let params = if func.params.is_empty() {
            if func.is_variadic {
                "...".to_string()
            } else {
                "void".to_string()
            }
        } else {
            let param_list = func.params.iter()
                .map(|(name, ty)| format!("{} {}", self.type_to_c(ty), name))
                .collect::<Vec<_>>()
                .join(", ");
            
            if func.is_variadic {
                format!("{}, ...", param_list)
            } else {
                param_list
            }
        };
        
        self.emit(&format!("extern {} {}({});", return_type, func.name, params));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{lexer::Lexer, parser::Parser};

    #[test]
    fn test_hello_codegen() {
        let source = "fn main() { print(\"Hello from U v0.7!\"); }".to_string();
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let decls = parser.parse().unwrap();

        let mut gen = CGenerator::new();
        let c_code = gen.generate_program(decls);

        assert!(c_code.contains("printf"));
        assert!(c_code.contains("Hello from U v0.7!"));
    }

    #[test]
    fn test_while_loop_codegen() {
        let source = "fn main() { var i = 0; while i < 10 { i = i + 1; } }".to_string();
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let decls = parser.parse().unwrap();

        let mut gen = CGenerator::new();
        let c_code = gen.generate_program(decls);

        assert!(c_code.contains("while"));
        assert!(c_code.contains("<"));
    }
}
