// c.rs — U v1.0 C Code Generator
// MIT License — Copyright (c) 2025 Webcien and U contributors

use crate::parser::{BinaryOp, Declaration, Expression, Function, Literal, Statement, Type, UnaryOp, Actor, Trait, TypeDef, TraitImpl};
use std::collections::HashSet;
use std::fmt::Write;

pub struct CGenerator {
    output: String,
    indent_level: usize,
    current_params: HashSet<String>,
}

impl CGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
            current_params: HashSet::new(),
        }
    }

    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }

    fn emit(&mut self, line: &str) {
        let indent_str = self.indent();
        writeln!(&mut self.output, "{}{}", indent_str, line).unwrap();
    }

    fn emitln(&mut self) {
        self.output.push('\n');
    }

    pub fn generate_program(&mut self, declarations: Vec<Declaration>) -> String {
        // Minimal header
        self.emit("// Generated by U v1.0 — DO NOT EDIT");
        self.emit("#include <stdio.h>");
        self.emit("#include <stdlib.h>");
        self.emit("#include <string.h>");
        self.emitln();

        // Forward declarations
        for decl in &declarations {
            if let Declaration::Function(f) = decl {
                self.generate_function_prototype(f);
            }
        }
        self.emitln();

        // Declarations
        for decl in declarations {
            self.generate_declaration(decl);
        }

        self.output.clone()
    }

    fn generate_function_prototype(&mut self, f: &Function) {
        let return_type = if f.name == "main" {
            "int"
        } else if f.return_type.is_some() {
            "int"
        } else {
            "void"
        };

        let params = if f.params.is_empty() {
            "void".to_string()
        } else {
            f.params
                .iter()
                .map(|(name, ty)| format!("{} {}", self.type_to_c(ty), name))
                .collect::<Vec<_>>()
                .join(", ")
        };

        self.emit(&format!("{} {}({});", return_type, f.name, params));
    }

    fn generate_declaration(&mut self, decl: Declaration) {
        match decl {
            Declaration::Function(f) => self.generate_function(f),
            Declaration::Actor(_) => {
                // Actors: struct generation deferred to v0.9
            }
            Declaration::Trait(_) => {
                // Traits: vtable generation deferred to v0.9
            }
            Declaration::TypeDef(_) => {
                // Type definitions: struct generation deferred to v0.9
            }
            Declaration::TraitImpl(_) => {
                // Trait implementations: method generation deferred to v0.9
            }
            Declaration::ExternBlock(block) => {
                self.generate_extern_block(block);
            }
            Declaration::UiBlock(ui) => {
                self.generate_ui_block(ui);
            }
        }
    }

    fn generate_function(&mut self, f: Function) {
        // Clear previous parameters
        self.current_params.clear();
        for (name, _) in &f.params {
            self.current_params.insert(name.clone());
        }

        // Return type (main always returns int, others based on signature)
        let return_type = if f.name == "main" {
            "int"
        } else if f.return_type.is_some() {
            "int"
        } else {
            "void"
        };

        let params = if f.params.is_empty() {
            "void".to_string()
        } else {
            f.params
                .iter()
                .map(|(name, ty)| format!("{} {}", self.type_to_c(ty), name))
                .collect::<Vec<_>>()
                .join(", ")
        };

        // Signature
        self.emit(&format!("{} {}({}) {{", return_type, f.name, params));
        self.indent_level += 1;

        // Body
        for stmt in f.body {
            self.generate_statement(stmt);
        }

        self.indent_level -= 1;
        self.emit("}");
        self.emitln();
    }

    fn type_to_c(&self, ty: &Type) -> String {
        match ty {
            Type::I32 => "int".to_string(),
            Type::Bool => "int".to_string(),
            Type::Str => "const char*".to_string(),
            Type::Ptr => "void*".to_string(),
            Type::Option(inner) => {
                format!("struct {{ {} value; int is_some; }}", self.type_to_c(inner))
            }
            Type::Result(ok, _) => {
                format!("struct {{ {} value; int is_ok; }}", self.type_to_c(ok))
            }
            Type::Custom(name) => format!("struct {}", name),
            Type::Generic { name, type_args: _ } => format!("struct {}", name),
            Type::FunctionPointer { params, return_type } => {
                let ret = if let Some(r) = return_type {
                    self.type_to_c(r)
                } else {
                    "void".to_string()
                };
                let param_str = params.iter()
                    .map(|t| self.type_to_c(t))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{}(*)({})", ret, param_str)
            }
        }
    }

    fn generate_statement(&mut self, stmt: Statement) {
        match stmt {
            Statement::Let { name, mutable: _, value } => {
                let c_type = self.expr_type_to_c(&value);
                let c_value = self.expr_to_c(value);
                self.emit(&format!("{} {} = {};", c_type, name, c_value));
            }
            Statement::Expr(expr) => {
                let c_expr = self.expr_to_c(expr);
                self.emit(&format!("{};", c_expr));
            }
            Statement::Return(expr) => {
                let c_expr = self.expr_to_c(expr);
                self.emit(&format!("return {};", c_expr));
            }
            Statement::If { condition, then_branch, else_branch } => {
                let cond = self.expr_to_c(condition);
                self.emit(&format!("if ({}) {{", cond));
                self.indent_level += 1;
                for stmt in then_branch {
                    self.generate_statement(stmt);
                }
                self.indent_level -= 1;
                if let Some(else_stmts) = else_branch {
                    self.emit("} else {");
                    self.indent_level += 1;
                    for stmt in else_stmts {
                        self.generate_statement(stmt);
                    }
                    self.indent_level -= 1;
                    self.emit("}");
                } else {
                    self.emit("}");
                }
            }
            Statement::While { condition, body } => {
                let cond = self.expr_to_c(condition);
                self.emit(&format!("while ({}) {{", cond));
                self.indent_level += 1;
                for stmt in body {
                    self.generate_statement(stmt);
                }
                self.indent_level -= 1;
                self.emit("}");
            }
            Statement::For { variable, iterable, body } => {
                let iter = self.expr_to_c(iterable);
                self.emit(&format!("for (int {} = 0; {} < {}; {}++) {{", variable, variable, iter, variable));
                self.indent_level += 1;
                for stmt in body {
                    self.generate_statement(stmt);
                }
                self.indent_level -= 1;
                self.emit("}");
            }
            Statement::Break => {
                self.emit("break;");
            }
            Statement::Continue => {
                self.emit("continue;");
            }
            Statement::Unsafe { body } => {
                // Unsafe blocks: generate C code directly without additional wrapping
                for stmt in body {
                    self.generate_statement(stmt);
                }
            }
        }
    }

    fn expr_type_to_c(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(Literal::Integer(_)) => "int".to_string(),
            Expression::Literal(Literal::String(_)) => "const char*".to_string(),
            Expression::Literal(Literal::Boolean(_)) => "int".to_string(),
            Expression::FunctionCall { name, .. } => {
                // For function calls, try to infer based on known patterns
                // Memory allocation functions
                if name == "malloc" || name == "calloc" || name == "realloc" {
                    return "void*".to_string();
                }
                
                // Skia functions that return pointers
                if name.starts_with("u_skia_") {
                    if name.contains("create") || name.contains("get_") || name.contains("version") {
                        return "void*".to_string();
                    }
                }
                
                // Default to int
                "int".to_string()
            }
            _ => "int".to_string(),
        }
    }

    fn expr_to_c(&self, expr: Expression) -> String {
        match expr {
            Expression::Literal(lit) => match lit {
                Literal::Integer(n) => n.to_string(),
                Literal::String(s) => format!("\"{}\"", s.escape_default()),
                Literal::Boolean(b) => if b { "1" } else { "0" }.to_string(),
            },
            Expression::Identifier(name) => name,
            Expression::FunctionCall { name, arguments } => {
                let args = arguments
                    .into_iter()
                    .map(|arg| self.expr_to_c(arg))
                    .collect::<Vec<_>>()
                    .join(", ");
                if name == "print" {
                    format!("printf(\"%d\\n\", {})", args)
                } else {
                    format!("{}({})", name, args)
                }
            }
            Expression::MethodCall {
                receiver: _,
                method: _,
                arguments: _,
            } => {
                "0 /* method call stub */".to_string()
            }
            Expression::Binary { left, operator, right } => {
                let left_c = self.expr_to_c(*left);
                let right_c = self.expr_to_c(*right);
                let op_str = match operator {
                    BinaryOp::Add => "+",
                    BinaryOp::Subtract => "-",
                    BinaryOp::Multiply => "*",
                    BinaryOp::Divide => "/",
                    BinaryOp::Modulo => "%",
                    BinaryOp::Equal => "==",
                    BinaryOp::NotEqual => "!=",
                    BinaryOp::Less => "<",
                    BinaryOp::LessEqual => "<=",
                    BinaryOp::Greater => ">",
                    BinaryOp::GreaterEqual => ">=",
                    BinaryOp::And => "&&",
                    BinaryOp::Or => "||",
                };
                format!("({} {} {})", left_c, op_str, right_c)
            }
            Expression::Unary { operator, operand } => {
                let op_c = self.expr_to_c(*operand);
                match operator {
                    UnaryOp::Not => format!("(!{})", op_c),
                    UnaryOp::Negate => format!("(-{})", op_c),
                }
            }
            Expression::Assignment { target, value } => {
                let val_c = self.expr_to_c(*value);
                format!("({} = {})", target, val_c)
            }
        }
    }

    fn generate_extern_block(&mut self, block: crate::parser::ExternBlock) {
        self.emit(&format!("// extern \"{}\" block", block.abi));
        for func in block.functions {
            self.generate_extern_function(&func);
        }
        self.emitln();
    }
    
    fn generate_extern_function(&mut self, func: &crate::parser::ExternFunction) {
        // Skip standard C library functions that are already declared in headers
        let stdlib_functions = [
            "printf", "scanf", "fprintf", "sprintf", "snprintf",
            "malloc", "free", "calloc", "realloc",
            "strlen", "strcpy", "strcmp", "strcat",
            "memcpy", "memset", "memmove",
            "fopen", "fclose", "fread", "fwrite",
            "exit", "abort", "atexit"
        ];
        
        if stdlib_functions.contains(&func.name.as_str()) {
            // Skip - already declared in standard headers
            return;
        }
        
        // Generate C function declaration
        let return_type = if let Some(ref ty) = func.return_type {
            self.type_to_c(ty)
        } else {
            "void".to_string()
        };
        
        let params = if func.params.is_empty() {
            if func.is_variadic {
                "...".to_string()
            } else {
                "void".to_string()
            }
        } else {
            let param_list = func.params.iter()
                .map(|(name, ty)| format!("{} {}", self.type_to_c(ty), name))
                .collect::<Vec<_>>()
                .join(", ");
            
            if func.is_variadic {
                format!("{}, ...", param_list)
            } else {
                param_list
            }
        };
        
        self.emit(&format!("extern {} {}({});", return_type, func.name, params));
    }

    fn generate_ui_block(&mut self, ui: crate::parser::UiBlock) {
        // Generate a C function that renders the UI using Skia
        self.emit(&format!("\nvoid render_ui_{}(void* canvas) {{", ui.name));
        self.indent_level += 1;
        
        // Generate widget rendering code
        self.generate_widget(&ui.root, "canvas");
        
        self.indent_level -= 1;
        self.emit("}\n");
    }

    fn generate_widget(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        // Generate Skia calls based on widget type
        match widget.widget_type.as_str() {
            "Container" => self.generate_container(widget, canvas_var),
            "Text" => self.generate_text(widget, canvas_var),
            "Button" => self.generate_button(widget, canvas_var),
            "Column" => self.generate_column(widget, canvas_var),
            "Row" => self.generate_row(widget, canvas_var),
            "TextField" => self.generate_textfield(widget, canvas_var),
            "ScrollView" => self.generate_scrollview(widget, canvas_var),
            "Image" => self.generate_image(widget, canvas_var),
            _ => {
                self.emit(&format!("// Unknown widget type: {}", widget.widget_type));
            }
        }
    }

    fn generate_container(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        use crate::parser::WidgetValue;
        
        let mut width = 100;
        let mut height = 100;
        let mut bg_color = (255, 255, 255);
        let mut child: Option<&crate::parser::Widget> = None;
        
        for (key, value) in &widget.properties {
            match key.as_str() {
                "width" => {
                    if let WidgetValue::Int(w) = value {
                        width = *w;
                    }
                }
                "height" => {
                    if let WidgetValue::Int(h) = value {
                        height = *h;
                    }
                }
                "background" => {
                    if let WidgetValue::Color { r, g, b } = value {
                        bg_color = (*r, *g, *b);
                    }
                }
                "child" => {
                    if let WidgetValue::Widget(w) = value {
                        child = Some(w.as_ref());
                    }
                }
                _ => {}
            }
        }
        
        // Generate Skia drawing code
        self.emit(&format!("void* paint = skia_create_paint();"));
        self.emit(&format!("skia_paint_set_color(paint, {}, {}, {}, 255);", bg_color.0, bg_color.1, bg_color.2));
        self.emit(&format!("skia_draw_rect({}, 0, 0, {}, {}, paint);", canvas_var, width, height));
        self.emit(&format!("skia_destroy_paint(paint);"));
        
        // Render child if present
        if let Some(child_widget) = child {
            self.generate_widget(child_widget, canvas_var);
        }
    }

    fn generate_text(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        use crate::parser::WidgetValue;
        
        let mut content = String::from("Text");
        let mut font_size = 14;
        let mut color = (0, 0, 0);
        
        for (key, value) in &widget.properties {
            match key.as_str() {
                "content" => {
                    if let WidgetValue::String(s) = value {
                        content = s.clone();
                    }
                }
                "fontSize" => {
                    if let WidgetValue::Int(fs) = value {
                        font_size = *fs;
                    }
                }
                "color" => {
                    if let WidgetValue::Color { r, g, b } = value {
                        color = (*r, *g, *b);
                    }
                }
                _ => {}
            }
        }
        
        self.emit(&format!("void* paint = skia_create_paint();"));
        self.emit(&format!("skia_paint_set_color(paint, {}, {}, {}, 255);", color.0, color.1, color.2));
        self.emit(&format!("skia_draw_text({}, \"{}\", 10, 30, {}, paint);", canvas_var, content, font_size));
        self.emit(&format!("skia_destroy_paint(paint);"));
    }

    fn generate_button(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        use crate::parser::WidgetValue;
        
        let mut text = String::from("Button");
        let mut width = 100;
        let mut height = 40;
        let mut on_click: Option<String> = None;
        
        for (key, value) in &widget.properties {
            match key.as_str() {
                "text" => {
                    if let WidgetValue::String(s) = value {
                        text = s.clone();
                    }
                }
                "width" => {
                    if let WidgetValue::Int(w) = value {
                        width = *w;
                    }
                }
                "height" => {
                    if let WidgetValue::Int(h) = value {
                        height = *h;
                    }
                }
                "onClick" => {
                    if let WidgetValue::Identifier(func) = value {
                        on_click = Some(func.clone());
                    }
                }
                _ => {}
            }
        }
        
        // Draw button background
        self.emit(&format!("void* paint = skia_create_paint();"));
        self.emit(&format!("skia_paint_set_color(paint, 100, 150, 250, 255);"));
        self.emit(&format!("skia_draw_rect({}, 10, 10, {}, {}, paint);", canvas_var, width, height));
        
        // Draw button text
        self.emit(&format!("skia_paint_set_color(paint, 255, 255, 255, 255);"));
        self.emit(&format!("skia_draw_text({}, \"{}\", 20, 35, 14, paint);", canvas_var, text));
        self.emit(&format!("skia_destroy_paint(paint);"));
        
        // Event handler (requires event loop integration)
        if let Some(handler) = on_click {
            self.emit(&format!("// onClick handler: {}() - requires event system", handler));
        }
    }

    fn generate_column(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        use crate::parser::WidgetValue;
        
        let mut children: Vec<&crate::parser::Widget> = Vec::new();
        
        for (key, value) in &widget.properties {
            if key == "children" {
                if let WidgetValue::WidgetList(widgets) = value {
                    for w in widgets {
                        children.push(w);
                    }
                }
            }
        }
        
        // Render children vertically
        for child in children {
            self.generate_widget(child, canvas_var);
        }
    }

    fn generate_row(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        use crate::parser::WidgetValue;
        
        let mut children: Vec<&crate::parser::Widget> = Vec::new();
        
        for (key, value) in &widget.properties {
            if key == "children" {
                if let WidgetValue::WidgetList(widgets) = value {
                    for w in widgets {
                        children.push(w);
                    }
                }
            }
        }
        
        // Render children horizontally
        for child in children {
            self.generate_widget(child, canvas_var);
        }
    }

    fn generate_textfield(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        use crate::parser::WidgetValue;
        
        let mut placeholder = String::from("Enter text...");
        let mut width = 200;
        let mut height = 40;
        
        for (key, value) in &widget.properties {
            match key.as_str() {
                "placeholder" => {
                    if let WidgetValue::String(s) = value {
                        placeholder = s.clone();
                    }
                }
                "width" => {
                    if let WidgetValue::Int(w) = value {
                        width = *w;
                    }
                }
                "height" => {
                    if let WidgetValue::Int(h) = value {
                        height = *h;
                    }
                }
                _ => {}
            }
        }
        
        // Draw text field background
        self.emit(&format!("void* paint = skia_create_paint();"));
        self.emit(&format!("skia_paint_set_color(paint, 255, 255, 255, 255);"));
        self.emit(&format!("skia_draw_rect({}, 10, 10, {}, {}, paint);", canvas_var, width, height));
        
        // Draw border
        self.emit(&format!("skia_paint_set_color(paint, 200, 200, 200, 255);"));
        self.emit(&format!("// TODO: Draw border (requires stroke support)"));
        
        // Draw placeholder text
        self.emit(&format!("skia_paint_set_color(paint, 150, 150, 150, 255);"));
        self.emit(&format!("skia_draw_text({}, \"{}\", 15, 30, 14, paint);", canvas_var, placeholder));
        self.emit(&format!("skia_destroy_paint(paint);"));
    }

    fn generate_scrollview(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        use crate::parser::WidgetValue;
        
        let mut child: Option<&crate::parser::Widget> = None;
        
        for (key, value) in &widget.properties {
            if key == "child" {
                if let WidgetValue::Widget(w) = value {
                    child = Some(w.as_ref());
                }
            }
        }
        
        self.emit(&format!("// ScrollView rendering (clipping not implemented in POC)"));
        
        // Render child if present
        if let Some(child_widget) = child {
            self.generate_widget(child_widget, canvas_var);
        }
    }

    fn generate_image(&mut self, widget: &crate::parser::Widget, canvas_var: &str) {
        use crate::parser::WidgetValue;
        
        let mut src = String::from("image.png");
        let mut width = 100;
        let mut height = 100;
        
        for (key, value) in &widget.properties {
            match key.as_str() {
                "src" => {
                    if let WidgetValue::String(s) = value {
                        src = s.clone();
                    }
                }
                "width" => {
                    if let WidgetValue::Int(w) = value {
                        width = *w;
                    }
                }
                "height" => {
                    if let WidgetValue::Int(h) = value {
                        height = *h;
                    }
                }
                _ => {}
            }
        }
        
        self.emit(&format!("// Image widget: {} ({}x{})", src, width, height));
        self.emit(&format!("// TODO: Load and draw image from: {}", src));
        
        // Draw placeholder rectangle
        self.emit(&format!("void* paint = skia_create_paint();"));
        self.emit(&format!("skia_paint_set_color(paint, 220, 220, 220, 255);"));
        self.emit(&format!("skia_draw_rect({}, 10, 10, {}, {}, paint);", canvas_var, width, height));
        self.emit(&format!("skia_destroy_paint(paint);"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{lexer::Lexer, parser::Parser};

    #[test]
    fn test_hello_codegen() {
        let source = "fn main() { print(\"Hello from U v1.0!\"); }".to_string();
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let decls = parser.parse().unwrap();

        let mut gen = CGenerator::new();
        let c_code = gen.generate_program(decls);

        assert!(c_code.contains("printf"));
        assert!(c_code.contains("Hello from U v1.0!"));
    }

    #[test]
    fn test_while_loop_codegen() {
        let source = "fn main() { var i = 0; while i < 10 { i = i + 1; } }".to_string();
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let decls = parser.parse().unwrap();

        let mut gen = CGenerator::new();
        let c_code = gen.generate_program(decls);

        assert!(c_code.contains("while"));
        assert!(c_code.contains("<"));
    }
}
